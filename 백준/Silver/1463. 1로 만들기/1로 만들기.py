# 각 숫자에 도달하는 최소 횟수를 저장하고, 
# 이전 값을 기반으로 +1씩 누적하면서 최솟값을 찾는 bottom-up DP 문제
# 작은 문제의 정답을 저장해두고, 큰 문제를 풀 때 그걸 재활용 하는 기법
# 1. 작은 문제로 나눈다.
# 2. 작은 문제를 풀어 정답을 구한다.
# 3. 작은 문제의 정답을 저장한다.
# 4. 큰문제를 작은 문제로 나누어 1~3을 반복한다.

# dp[i]에는 i가 1이 되기까지 최소한으로 필요한 연산 횟수가 들어간다.


n = int(input())
# dp크기 설정
dp = [0] * (n+1)  # 실제로 사용하는 건 dp[1] ~ dp[n]

# 1은 이미 1이니까 패스 2부터 시작
for i in range(2, n+1):
    # 1을 빼는 경우
    dp[i] = dp[i-1] + 1  # +1을 해주면서 횟수 증가
    
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1)  # 1을 더하는 이유: 결과가 아닌 계산한 횟수를 구하는 것이기 때문
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i // 3] + 1)

print(dp[n])